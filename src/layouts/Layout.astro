---
interface Props {
  title: string;
  description: string;
}

const { title, description } = Astro.props;

import "@fontsource/dm-serif-display";
import "@fontsource-variable/red-hat-display";
---

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="description" content="Astro description" />
    <meta name="viewport" content="width=device-width" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <meta name="generator" content={Astro.generator} />
    <title>{title}</title>
  </head>
  <body>
    <img src="/blurCorner.png" aria-hidden="true" class="blurCorner" />
    <canvas id="stars"></canvas>
    <div class="bottom">
      <h1 id="title">{title}</h1>
      <p id="description">{description}</p>
    </div>
    <slot />
    <lottie-player
      src="/menu.json"
      background="transparent"
      speed="1"
      class="menuIcon"></lottie-player>
    <div class="menu blue-to-black">
      <ul>
        <li><a href="/" class="hover-underline-animation">Home</a></li>
        <li><a href="/about" class="hover-underline-animation">About</a></li>
        <li>
          <a href="/projects" class="hover-underline-animation">Projects</a>
        </li>
      </ul>
    </div>
  </body>
</html>

<script>
  //@ts-nocheck
  const canvas = document.getElementById("stars")! as HTMLCanvasElement;
  const ctx = canvas.getContext("2d");

  let screen = {};
  let stars = [];
  let params = { speed: 2, number: 300, extinction: 4 };

  setupStars();
  updateStars();

  // update stars on resize to keep the thing centered
  window.onresize = function () {
    setupStars();
  };

  // star constructor
  function Star() {
    this.x = Math.random() * canvas.width;
    this.y = Math.random() * canvas.height;
    this.z = Math.random() * canvas.width;

    this.move = function () {
      this.z -= params.speed;
      if (this.z <= 0) {
        this.z = canvas.width;
      }
    };

    this.show = function () {
      let x, y, rad, opacity;
      x = (this.x - screen.c[0]) * (canvas.width / this.z);
      x = x + screen.c[0];
      y = (this.y - screen.c[1]) * (canvas.width / this.z);
      y = y + screen.c[1];
      rad = canvas.width / this.z;
      opacity =
        rad > params.extinction ? 1.5 * (2 - rad / params.extinction) : 1;

      ctx.beginPath();
      ctx.fillStyle = "rgba(255, 255, 255, " + opacity + ")";
      ctx.arc(x, y, rad, 0, Math.PI * 2);
      ctx.fill();
    };
  }

  // setup <canvas>, create all the starts
  function setupStars() {
    screen = {
      w: window.innerWidth,
      h: window.innerHeight,
      c: [window.innerWidth * 0.5, window.innerHeight * 0.5],
    };
    window.cancelAnimationFrame(updateStars);
    canvas.width = screen.w;
    canvas.height = screen.h;
    stars = [];
    for (let i = 0; i < params.number; i++) {
      stars[i] = new Star();
    }
  }

  function updateStars() {
    ctx.fillStyle = "black";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    stars.forEach(function (s) {
      s.show();
      s.move();
    });
    window.requestAnimationFrame(updateStars);
  }
</script>
<script>
  import type { LottiePlayer } from "@lottiefiles/lottie-player";
  import "@lottiefiles/lottie-player";
  import anime from "animejs";
  import { breakApart } from "../utils";

  breakApart("letters", "#title", false, 1000).play();
  breakApart("letters", "#description", false, 2000).play();
  const menuAnim = breakApart(
    "letters",
    ".menu ul li a",
    false,
    0,
    true,
    anime.stagger(100)
  );
  // menu animation
  const menu = document.querySelector(".menuIcon") as LottiePlayer;
  const menuEl = document.querySelector(".menu") as HTMLElement;

  let menuState: boolean = false;
  menu.addEventListener("click", () => {
    if (menuState) {
      menu.setDirection(-1);
      menu.setSpeed(2.2);
      menu.play();
      menuEl.style.transform = "translateX(100%)";
      menuState = false;
    } else {
      menu.setDirection(1);
      menu.setSpeed(2);
      menu.play();
      menuEl.style.transform = "translateX(0%)";
      menuAnim.play();
      menuState = true;
    }
  });

  // menu

  const menuItems = document.querySelectorAll(".menu ul li a");
  menuItems.forEach((item) => {
    item.addEventListener("click", () => {
      menu.setDirection(-1);
      menu.setSpeed(2.2);
      menu.play();
      menuState = false;
    });
  });
</script>
<style>
  /* slide out menu */
  .menu {
    position: fixed;
    top: 0;
    right: 0;
    z-index: 800;
    width: 50vw;
    height: 100vh;
    background: var(--accent-gradient);
    transform: translateX(100%);
    transition: transform 0.5s ease-in-out;
    padding: 0 4rem;
  }
  .menu ul {
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: start;
    height: 100%;
    margin: 0;
    padding: 0;
  }
  .menu ul li {
    list-style: none;
    margin: 0;
    padding: 0;
    margin-bottom: 2rem;
  }
  .menu ul li a {
    color: #fff;
    font-size: 4rem;
    font-style: normal;
    font-weight: 400;
    line-height: normal;
    margin: 0;
    font-family: "DM Serif Display", sans-serif;
    text-decoration: none;
  }

  .menuIcon {
    position: absolute;
    top: 0;
    right: 0;
    z-index: 1000;
    width: 8rem;
    height: 8rem;
  }
  .menuIcon:hover {
    cursor: pointer;
  }
  #stars {
    position: absolute;
    z-index: -2;
    bottom: 0;
    right: 0;
    width: 100vw;
    height: 100vh;
  }
  .blurCorner {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    object-fit: cover;
    object-position: top left;
    pointer-events: none;
  }
  .bottom {
    position: absolute;
    bottom: 0;
    left: 0;
    margin: 0 4rem;
    display: flex;
    width: calc(100% - 8rem);
    align-items: last baseline;
    justify-content: space-between;
    text-align: center;
  }
  .bottom > h1 {
    color: #fff;
    font-size: 5rem;
    width: 3rem;
    font-family: "DM Serif Display", sans-serif;
    font-weight: 400;
    line-height: normal;
    perspective: 4000px;
  }
  .bottom > p {
    color: #fff;
    font-size: 1.5rem;
    font-style: normal;
    font-weight: 400;
    line-height: normal;
    margin: 0;
    font-family: "Red Hat Display Variable", sans-serif;
  }
</style>
<style is:global>
  :root {
    --accent-gradient: linear-gradient(
      99.9deg,
      rgb(14, 14, 17) 41.2%,
      rgb(5, 4, 89) 84.8%
    );
  }
  .blue-to-black {
    background-image: linear-gradient(
      to right in oklch,
      rgb(14, 14, 17) 41.2%,
      rgb(5, 4, 89) 84.8%
    );
  }
  html {
    font-family: system-ui, sans-serif;
    background: #0b0c0e;
    background-size: 224px;
    padding: 0;
    margin: 0;
  }
  body {
    margin: 0;
    padding: 0;
  }
  code {
    font-family: Menlo, Monaco, Lucida Console, Liberation Mono,
      DejaVu Sans Mono, Bitstream Vera Sans Mono, Courier New, monospace;
  }
  .hover-underline-animation {
    display: inline-block;
    position: relative;
    color: #0087ca;
  }

  .hover-underline-animation::after {
    content: "";
    position: absolute;
    width: 100%;
    transform: scaleX(0);
    height: 2px;
    bottom: 0;
    left: 0;
    background-color: #f5f5f5;
    transform-origin: bottom right;
    transition: transform 0.25s ease-out;
  }

  .hover-underline-animation:hover::after {
    transform: scaleX(1);
    transform-origin: bottom left;
  }
</style>
